install.packages("broom")
library(broom)
source(here::here("R/helpers.R"))  # absolute path to R/
library(dplyr)
library(tidyverse)
library(patchwork)
# Read in the dataset (consisting of 3 NHANES merged datasets on lab values and blood pressure. This dataset only contains the variables of interest and has been filtered by the appropriate age range)
nhanes_filtered <- readRDS(here::here("data/nhanes_data.rds"))
# Explore where missing values occur on a heatmap of the data
library(naniar)
vis_miss(nhanes_filtered)
miss_var_summary(nhanes_filtered)
# create indicators
nhanes_filtered$lab_missing  <- as.integer(
is.na(nhanes_filtered$LBXBPB) | is.na(nhanes_filtered$LBXBCD) | is.na(nhanes_filtered$LBXBMN)
)
nhanes_filtered$bp_missing   <- as.integer(
is.na(nhanes_filtered$BPXSY1) | is.na(nhanes_filtered$BPXDI1)
)
# Contingency table
tab <- table(nhanes_filtered$lab_missing, nhanes_filtered$bp_missing)
tab
# Chi-squared test
chisq.test(tab)
# Effect size: Cramer's V (equivalent to phi coefficient for 2x2)
library(rcompanion)
cramerV(tab)
# logistic regression predicting missingness (binary outcome) on other covariates
model_lab <- glm(lab_missing ~ RIDAGEYR + RIAGENDR + RIDRETH1,
data = nhanes_filtered, family = binomial)
summary(model_lab)
model_bp  <- glm(bp_missing ~ RIDAGEYR + RIAGENDR + RIDRETH1,
data = nhanes_filtered, family = binomial)
summary(model_bp)
library(mice)
# Impute filtered dataset
# Define methods per variable
meth <- make.method(nhanes_filtered)
meth[c("LBXBPB", "LBXBCD", "LBXBMN")] <- "pmm"
meth["SEQN"] <- ""  # ID variable excluded
# Perform imputation
set.seed(123)
imp <- mice(
nhanes_filtered,
m = 1,       # single imputed dataset
method = meth,
maxit = 20,
printFlag = FALSE    # <-- suppress iteration output
)
# Complete data after imputation
nhanes_imputed <- complete(imp, 1)
# confirm no missing data for predictors
sapply(nhanes_imputed, function(x) sum(is.na(x)))
# Apply helper function to lab values (numeric variables) to remove outliers and plot the data
numeric_vars <- c("LBXBPB", "LBXBCD", "LBXBMN", "BPXSY1", "BPXDI1")
nhanes_clean <- nhanes_imputed %>%
# Remove outliers -> "_clean" columns
mutate(across(all_of(numeric_vars), remove_outliers, .names = "{.col}_clean"))  %>%
# Drop rows with NA values introduced by outlier removal
drop_na()
# Save cleaned data
saveRDS(nhanes_clean, here::here("data/study2/nhanes_data_cleaned.rds"))
# Read in the cleaned data
nhanes_clean <- readRDS(here::here("data/study2/nhanes_data_cleaned.rds"))
library(labelled)
library(dataReporter)
# Assign variable labels
var_labels <- c(
SEQN = "Subject ID: Individual Identifier",
RIDAGEYR = "Age in years at screening (40-65)",
RIAGENDR = "Sex: male or female",
RIDRETH1 = "Race / Ethnicity",
LBXBPB = "Blood lead (µg/dL)",
LBXBPB_clean = "Blood lead after outlier removal",
LBXBCD = "Blood cadmium (µg/dL)",
LBXBCD_clean = "Blood cadmium after outlier removal",
LBXBMN = "Blood manganese (µg/dL)",
LBXBMN_clean = "Blood manganese after outlier removal",
BPXSY1 = "Systolic BP, first reading",
BPXSY1_clean = "Systolic BP, first reading after outlier removal",
BPXDI1 = "Diastolic BP, first reading",
BPXDI1_clean = "Diastolic BP, first reading after outlier removal"
)
# Convert your named character vector to a named list
var_labels_list <- as.list(var_labels)
# Apply labels to the dataframe
nhanes_clean <- set_variable_labels(nhanes_clean, .labels = var_labels_list)
makeCodebook(nhanes_clean, file = here::here("data/study2/codebook.html"), output = "html", replace = TRUE)
library(dplyr)
library(purrr)
library(tibble)
# Numeric variables codebook
numeric_codebook <- nhanes_clean %>%
select(where(is.numeric)) %>%
map_dfr(~{
tibble(
type = class(.x)[1],
missing = sum(is.na(.x)),
min = min(.x, na.rm = TRUE),
q25 = quantile(.x, 0.25, na.rm = TRUE),
median = median(.x, na.rm = TRUE),
mean = mean(.x, na.rm = TRUE),
q75 = quantile(.x, 0.75, na.rm = TRUE),
max = max(.x, na.rm = TRUE)
)
}, .id = "variable")
# Display results
print(numeric_codebook, n = Inf)
# Categorical variables codebook
categorical_codebook <- nhanes_clean %>%
select(where(~is.factor(.x) || is.character(.x))) %>%
map_dfr(~{
unique_vals <- unique(.x)
tibble(
type = class(.x)[1],
missing = sum(is.na(.x)),
n_unique = length(unique_vals),
levels = paste(head(unique_vals, 10), collapse = ", ") # show first 10
)
}, .id = "variable")
# Display results
print(categorical_codebook, n = Inf)
# categorical codebook -- easier to see
categorical_vars <- c("RIAGENDR", "RIDRETH1")
categorical_summary <- lapply(categorical_vars, function(var) {
nhanes_clean %>%
group_by(.data[[var]]) %>%
summarise(
count = n(),
.groups = "drop"
) %>%
mutate(
variable = var,
missing = sum(is.na(nhanes_clean[[var]]))
) %>%
select(variable, level = .data[[var]], count, missing)
}) %>%
bind_rows()
categorical_summary
head(nhanes_clean)
library(psych)
# numeric variables
describe(nhanes_clean)
# Categorical variables
library(dplyr)
library(tidyr)
# List of categorical variables to summarize
cat_vars <- c("RIAGENDR", "RIDRETH1")
# Function to summarize one categorical variable
summarize_cat <- function(var_name, data) {
data %>%
count(.data[[var_name]]) %>%
mutate(
Proportion = n / sum(n),
variable = var_name,
level = .data[[var_name]]
) %>%
select(variable, level, n, Proportion)
}
# Loop over variables and combine
cat_summary <- lapply(cat_vars, summarize_cat, data = nhanes_clean) %>%
bind_rows()
cat_summary
library(rsample)
set.seed(123)  # for reproducibility
# Create a split object
split <- initial_split(nhanes_clean, prop = 0.8)
# Extract training and testing datasets
train_data <- training(split)
test_data  <- testing(split)
# ----------- Demonstrate that each subject is in exactly one set
all_subjects <- nhanes_clean$SEQN
train_subjects <- train_data$SEQN
test_subjects  <- test_data$SEQN
# a) no overlap
intersect(train_subjects, test_subjects)  # should return integer(0)
# b) all subjects accounted for
setdiff(all_subjects, c(train_subjects, test_subjects))  # should return integer(0)
# Generate distribution plots
p_sbp <- visualize_data(nhanes_imputed, "BPXSY1", "Systolic BP")
p_sbp
# Linear regression predicting systolic BP from heavy metal concentration in blood
model <- lm(BPXSY1_clean ~ LBXBPB_clean + LBXBCD_clean + LBXBMN_clean + RIDAGEYR + RIAGENDR + RIDRETH1, data = train_data)
# Model fit statistics
model_stats <- glance(model) %>%
select(r.squared, adj.r.squared, AIC, BIC) %>%
mutate(across(where(is.numeric), round, 3))
# Summarize results
summary(model)
model_stats
library(ggplot2)
# Create a dataframe for plotting
resid_data <- data.frame(
Fitted = model$fitted.values,
Residuals = model$residuals
)
ggplot(resid_data, aes(x = Fitted, y = Residuals)) +
geom_point(alpha = 0.6) +                        # scatter points
geom_smooth(method = "loess", se = FALSE, color = "blue") + # LOESS smooth
geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
theme_minimal() +
labs(title = "Residuals vs Fitted with LOESS",
x = "Fitted values",
y = "Residuals")
# Linear regression predicting systolic BP from heavy metal concentration in blood
model_small <- lm(BPXSY1_clean ~ LBXBPB_clean + LBXBCD_clean + LBXBMN_clean, data = train_data)
# Model fit statistics
model_stats_small <- glance(model_small) %>%
select(r.squared, adj.r.squared, AIC, BIC) %>%
mutate(across(where(is.numeric), round, 3))
# Summarize results
summary(model_small)
model_stats_small
# Create a dataframe for plotting
resid_data <- data.frame(
Fitted = model_small$fitted.values,
Residuals = model_small$residuals
)
ggplot(resid_data, aes(x = Fitted, y = Residuals)) +
geom_point(alpha = 0.6) +                        # scatter points
geom_smooth(method = "loess", se = FALSE, color = "blue") + # LOESS smooth
geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
theme_minimal() +
labs(title = "Residuals vs Fitted with LOESS",
x = "Fitted values",
y = "Residuals")
# Linear regression predicting systolic BP from heavy metal concentration in blood
model <- lm(BPXSY1_clean ~ LBXBPB_clean + LBXBCD_clean + LBXBMN_clean + RIDAGEYR + RIAGENDR + RIDRETH1, data = test_data)
# Model fit statistics
model_stats <- glance(model) %>%
select(r.squared, adj.r.squared, AIC, BIC) %>%
mutate(across(where(is.numeric), round, 3))
# Summarize results
summary(model)
model_stats
library(ggplot2)
# Create a dataframe for plotting
resid_data <- data.frame(
Fitted = model$fitted.values,
Residuals = model$residuals
)
ggplot(resid_data, aes(x = Fitted, y = Residuals)) +
geom_point(alpha = 0.6) +                        # scatter points
geom_smooth(method = "loess", se = FALSE, color = "blue") + # LOESS smooth
geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
theme_minimal() +
labs(title = "Residuals vs Fitted with LOESS",
x = "Fitted values",
y = "Residuals")
# Linear regression predicting systolic BP from heavy metal concentration in blood
model_small <- lm(BPXSY1_clean ~ LBXBPB_clean + LBXBCD_clean + LBXBMN_clean, data = train_data)
# Model fit statistics
model_stats_small <- glance(model_small) %>%
select(r.squared, adj.r.squared, AIC, BIC) %>%
mutate(across(where(is.numeric), round, 3))
# Summarize results
summary(model_small)
model_stats_small
# Create a dataframe for plotting
resid_data <- data.frame(
Fitted = model_small$fitted.values,
Residuals = model_small$residuals
)
ggplot(resid_data, aes(x = Fitted, y = Residuals)) +
geom_point(alpha = 0.6) +                        # scatter points
geom_smooth(method = "loess", se = FALSE, color = "blue") + # LOESS smooth
geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
theme_minimal() +
labs(title = "Residuals vs Fitted with LOESS",
x = "Fitted values",
y = "Residuals")
# Linear regression predicting systolic BP from heavy metal concentration in blood
model_small <- lm(BPXSY1_clean ~ LBXBPB_clean + LBXBCD_clean + LBXBMN_clean, data = test_data)
# Model fit statistics
model_stats_small <- glance(model_small) %>%
select(r.squared, adj.r.squared, AIC, BIC) %>%
mutate(across(where(is.numeric), round, 3))
# Summarize results
summary(model_small)
model_stats_small
# Create a dataframe for plotting
resid_data <- data.frame(
Fitted = model_small$fitted.values,
Residuals = model_small$residuals
)
ggplot(resid_data, aes(x = Fitted, y = Residuals)) +
geom_point(alpha = 0.6) +                        # scatter points
geom_smooth(method = "loess", se = FALSE, color = "blue") + # LOESS smooth
geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
theme_minimal() +
labs(title = "Residuals vs Fitted with LOESS",
x = "Fitted values",
y = "Residuals")
# Generate predictions
pred_small <- predict(model_small, newdata = test_data)
pred_big   <- predict(model, newdata = test_data)
# Actual outcome (original scale)
actual <- test_data$BPXSY1_clean
# Compute prediction errors
errors <- tibble(
actual = actual,
pred_small = pred_small_bt,
pred_big = pred_big_bt,
err_small = pred_small_bt - actual,
err_big   = pred_big_bt - actual,
abs_err_small = abs(err_small),
abs_err_big = abs(err_big),
sq_err_small = err_small^2,
sq_err_big = err_big^2
)
# Generate predictions
pred_small <- predict(model_small, newdata = test_data)
pred_big   <- predict(model, newdata = test_data)
# Actual outcome (original scale)
actual <- test_data$BPXSY1_clean
# Compute prediction errors
errors <- tibble(
actual = actual,
pred_small = pred_small,
pred_big = pred_big,
err_small = pred_small - actual,
err_big   = pred_big - actual,
abs_err_small = abs(err_small),
abs_err_big = abs(err_big),
sq_err_small = err_small^2,
sq_err_big = err_big^2
)
# Generate predictions
pred_small <- predict(model_small, newdata = test_data)
pred_big   <- predict(model, newdata = test_data)
# Actual outcome (original scale)
actual <- test_data$BPXSY1_clean
# Compute prediction errors
errors <- tibble(
actual = actual,
pred_small = pred_small,
pred_big = pred_big,
err_small = pred_small - actual,
err_big   = pred_big - actual,
abs_err_small = abs(err_small),
abs_err_big = abs(err_big),
sq_err_small = err_small^2,
sq_err_big = err_big^2
)
errors
# Root Mean Squared Prediction Error (RMSPE)
rmspe_small <- sqrt(mean(errors$sq_err_small))
rmspe_big   <- sqrt(mean(errors$sq_err_big))
# Mean Absolute Prediction Error (MAPE)
mape_small <- mean(errors$abs_err_small)
mape_big   <- mean(errors$abs_err_big)
# Maximum Absolute Error (MaxAE)
maxae_small <- max(errors$abs_err_small)
maxae_big   <- max(errors$abs_err_big)
# Squared correlation between actual and predicted (validated R^2)
val_r2_small <- cor(errors$actual, errors$pred_small)^2
val_r2_big   <- cor(errors$actual, errors$pred_big)^2
# Summarize in a tibble
error_summary <- tibble(
Model = c("Small Model", "Big Model"),
RMSPE = c(rmspe_small, rmspe_big),
MAPE = c(mape_small, mape_big),
MaxAE = c(maxae_small, maxae_big),
R2_val = c(val_r2_small, val_r2_big)
) %>%
mutate(across(where(is.numeric), round, 3))
# Display nicely
library(DT)
datatable(error_summary, options = list(dom = 't', paging = FALSE), rownames = FALSE)
# Root Mean Squared Prediction Error (RMSPE)
rmspe_small <- sqrt(mean(errors$sq_err_small))
rmspe_big   <- sqrt(mean(errors$sq_err_big))
# Mean Absolute Prediction Error (MAPE)
mape_small <- mean(errors$abs_err_small)
mape_big   <- mean(errors$abs_err_big)
# Maximum Absolute Error (MaxAE)
maxae_small <- max(errors$abs_err_small)
maxae_big   <- max(errors$abs_err_big)
# Squared correlation between actual and predicted (validated R^2)
val_r2_small <- cor(errors$actual, errors$pred_small)^2
val_r2_big   <- cor(errors$actual, errors$pred_big)^2
# Summarize in a tibble
error_summary <- tibble(
Model = c("Small Model", "Big Model"),
RMSPE = c(rmspe_small, rmspe_big),
MAPE = c(mape_small, mape_big),
MaxAE = c(maxae_small, maxae_big),
R2_val = c(val_r2_small, val_r2_big)
) %>%
mutate(across(where(is.numeric), round, 3))
# Display nicely
library(DT)
datatable(error_summary, options = list(dom = 't', paging = FALSE), rownames = FALSE)
# Root Mean Squared Prediction Error (RMSPE)
rmspe_small <- sqrt(mean(errors$sq_err_small))
rmspe_big   <- sqrt(mean(errors$sq_err_big))
# Mean Absolute Prediction Error (MAPE)
mape_small <- mean(errors$abs_err_small)
mape_big   <- mean(errors$abs_err_big)
# Maximum Absolute Error (MaxAE)
maxae_small <- max(errors$abs_err_small)
maxae_big   <- max(errors$abs_err_big)
# Squared correlation between actual and predicted (validated R^2)
val_r2_small <- cor(errors$actual, errors$pred_small)^2
val_r2_big   <- cor(errors$actual, errors$pred_big)^2
# Summarize in a tibble
error_summary <- tibble(
Model = c("Small Model", "Big Model"),
RMSPE = c(rmspe_small, rmspe_big),
MAPE = c(mape_small, mape_big),
MaxAE = c(maxae_small, maxae_big),
R2_val = c(val_r2_small, val_r2_big)
) %>%
mutate(across(where(is.numeric), round, 3))
# Display nicely
error_summary
# Root Mean Squared Prediction Error (RMSPE)
rmspe_small <- sqrt(mean(errors$sq_err_small))
rmspe_big   <- sqrt(mean(errors$sq_err_big))
# Mean Absolute Prediction Error (MAPE)
mape_small <- mean(errors$abs_err_small)
mape_big   <- mean(errors$abs_err_big)
# Maximum Absolute Error (MaxAE)
maxae_small <- max(errors$abs_err_small)
maxae_big   <- max(errors$abs_err_big)
# Squared correlation between actual and predicted (validated R^2)
val_r2_small <- cor(errors$actual, errors$pred_small)^2
val_r2_big   <- cor(errors$actual, errors$pred_big)^2
# Summarize in a tibble
error_summary <- tibble(
Model = c("Small Model", "Big Model"),
RMSPE = c(rmspe_small, rmspe_big),
MAPE = c(mape_small, mape_big),
MaxAE = c(maxae_small, maxae_big),
R2_val = c(val_r2_small, val_r2_big)
) %>%
mutate(across(where(is.numeric), round, 3))
# Display nicely
library(DT)
datatable(error_summary, options = list(dom = 't', paging = FALSE), rownames = FALSE)
library(ggplot2)
# Combine into long format for easier plotting
plot_data <- errors %>%
select(actual, pred_small, pred_big) %>%
pivot_longer(cols = starts_with("pred"), names_to = "model", values_to = "predicted") %>%
mutate(model = recode(model, "pred_small" = "Small Model", "pred_big" = "Big Model"))
# Scatter plot: Observed vs Predicted
ggplot(plot_data, aes(x = predicted, y = actual, color = model)) +
geom_point(alpha = 0.6) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed") +  # line for perfect prediction
facet_wrap(~ model) +
labs(
x = "Predicted Systolic BP",
y = "Observed Systolic BP",
title = "Observed vs Predicted Systolic BP in Test Sample"
) +
theme_minimal() +
theme(
axis.text = element_text(size = 12),
axis.title = element_text(size = 14),
plot.title = element_text(size = 16, face = "bold")
)
# Root Mean Squared Prediction Error (RMSPE)
rmspe_small <- sqrt(mean(errors$sq_err_small))
rmspe_big   <- sqrt(mean(errors$sq_err_big))
# Mean Absolute Prediction Error (MAPE)
mape_small <- mean(errors$abs_err_small)
mape_big   <- mean(errors$abs_err_big)
# Maximum Absolute Error (MaxAE)
maxae_small <- max(errors$abs_err_small)
maxae_big   <- max(errors$abs_err_big)
# Squared correlation between actual and predicted (validated R^2)
val_r2_small <- cor(errors$actual, errors$pred_small)^2
val_r2_big   <- cor(errors$actual, errors$pred_big)^2
# Summarize in a tibble
error_summary <- tibble(
Model = c("Small Model", "Big Model"),
RMSPE = c(rmspe_small, rmspe_big),
MAPE = c(mape_small, mape_big),
MaxAE = c(maxae_small, maxae_big),
R2_val = c(val_r2_small, val_r2_big)
) %>%
mutate(across(where(is.numeric), round, 3))
# Display nicely
library(DT)
datatable(error_summary, options = list(dom = 't', paging = FALSE), rownames = FALSE)
